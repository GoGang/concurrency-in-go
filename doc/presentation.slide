Concurrency in Go
28 Mai 2015

Benjamin Chenebault & Jacques Antoine Massé
Orange Applications for Business

* Sommaire

- Quelques mots
- La concurrence c'est pas du parallélisme
- Golang en 5 slides (à peine)
- 10' Live coding

* Quelques mots

* Qui sommes nous ?

Deux développeurs bordelais,

- Issus du monde Java,
- Spécialisés dans la conception de plateformes haute disponibilité,
- Noyés dans des problématiques de programmation concurrente,
- Et bercés au quotidien dans des problémes de flux réseau... 

* Moore or not Moore

.image images/moore.jpg _ 500

* Ok, et alors ?

.image images/thread.jpg _ 300

.image images/monkey.jpg _ 200

* La concurrence, c'est pas du parallélisme

* Concurrence != Parallélisme

- Concurrence : Conception de programmes comme un ensemble processus s'exécutant indépendamment. C'est du design.

- Parallélisme : Exécution de processus simultanés. C'est une question d'architecture de machine, sur une machine monocoeur, on peut pas paralléliser.

* Exemple : Indexation des titres de pages wikipedia en

- Non concurrent, non parallèle

.image images/concurrence1.png _ 700

* Exemple : Indexation des titres de pages wikipedia en

- Concurrent ? Parallèle ?

.image images/concurrence2.png _ 900

* Exemple : Indexation des titres de pages wikipedia en

- Concurrent ? Parallèle ?

.image images/concurrence3.png _ 800

* Conception concurrente

- Paradigme de programmation
- Consiste à décomposer un système complexe en sous-systèmes plus simples
- On ne parle pas d'objets, ni de fonctions, ni de procédures, mais de processus

- Ces sous-systèmes peuvent fonctionner en concurrence…
- … et potentiellement en parallèle

* Thread et locks

- le modèle habituel

.image images/sharedmemory.png _ 800

* Thread et locks : avantages/inconvénients

- + Analogue au fonctionnement de la machine

- - Identification des points de synchronisation difficile
- - Difficilement testable, débuggage chronophage
- - "Saupoudrage" de la concurrence sur le design métier
- - Pilotage de la contention

* Passage de message

- Communicating Sequential Process (Hoare, 1978)

.image images/messagepassing.png _ 800

Patterns : Pipelines, fan in/out, timeout, pub/sub,…

* Passage de message : avantages/inconvénients

- + Concurrence paradigme du langage
- + Patterns de conception connus
- + Métier == concurrence
- + Testable
- + Outillage dédié

- - On perd de vue le fonctionnement de la machine

* Passage de message : quelques patterns

- Fan in/Fan out
- Active Object/Monitor Object
- Programmation par évènements
- Message queuing
- Publication/Subscription

- patterns spécifiques au langage (quit channel, pools de channels, ...)

* Un tour de Go en 5 slides

* Cf Wikipedia

- V1.0 sortie en mars 2012
- Créé par R.Pike, K.Thompson, R. Griesemer
- Procédural, un peu objet, un peu fonctionnel
- Garbage collecté
- Compilé
- Typage fort, statique
- Orienté concurrence
- Open source

* Les channels

- Primitive du langage 
- File FIFO
- Assure la communication inter process
- `select` permet de "poller" plusieurs channels

* Les goroutines

- Exécution d'un appel de fonction dans un processus dédié
- Mot clé `go`
- Primitive du langage
- Faible occupation mémoire (~4ko/goroutine)
- Task switching peu significatif
- Multiplexé sur un ou plusieurs threads de l'OS

* Du code

.code -edit -numbers code/goroutine.go /^func producer/,/^}/
.code -edit -numbers code/goroutine.go /^func consumer/,/^}/

* Du code

.play code/goroutine.go /^func main/,/^}/

* Scheduling

* Cœurs et goroutines

.image images/gomodel.png _ 600

* Cœurs et goroutines

.image images/gomodel2.png _ 450


* Cœurs et goroutines

.image images/gomodel3.png _ 700

* Traçage du scheduler 

.code code/schedule.go /^const/,/^}/

go build schedule.go && GODEBUG=schedtrace=10 ./schedule -cores 4

* Traçage du scheduler 

     SCHED 0ms: gomaxprocs=1 idleprocs=0 threads=2 spinningthreads=0 idlethreads=0 runqueue=0 [2]
     SCHED 11ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=2933 [159 128 125 128]
     SCHED 29ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=2933 [128 126 108 109]

- gomaxprocs : nombre de processeurs logiques utilisés
- idleprocs : nombre de processus en attente

- threads : threads de l'OS utilisés par le runtime (1 pour le processeur go)
- spinningthreads : 
- idlethreads : threads inoccupés

- runqueue : nombre de goroutines en file d'attente globale
- [nombre de goroutines par file d'attente locale]

* 10' live coding

* MapReduce

Comment indexer le contenu de Wikipedia avec 30 lignes de code ?

.image images/mapreduce.png _ 700

* Références

.image images/book1.jpg _ 200
.image images/book2.jpg _ 200

* Questions ?

* Annexe

- Retour d'expérience sur Go : https://github.com/GoGang/RetourDExperience
